# 代码1

## 1. 错误类型

Runtime Error

## 2. 错误原因

处理连消时没有考虑边界情况。（第19行没有考虑left == 0的情况）

导致进入递归函数后取string中位置为-1的元素。(第10行)

## 3. 测例

AA
1
0 A

## 4. 测例构造思路

由于连消时没有考虑到边界，使得一些本不可能连消的边界情况递归进入函数，引发错误，因此构造一个会触发边界条件而错误进入连消处理的情况。测例中插入A之后消除变为空串，此时错误的进入连消处理并试图取位置为-1处的元素将导致错误。

# 代码2

## 1. 错误类型

Runtime Error

## 2. 错误原因

处理连消时没有考虑边界情况。（第23行没有考虑next == 0 且字符串已经为空的情况）

导致进入递归函数后在改变right的步骤中取到了string中位置为-1的元素。（第14行）

## 3. 测例

AA
1
0 A

## 4. 测例构造思路

由于连消时没有考虑到边界，引发错误，因此构造一个消除之后变为空串的例子。测例中插入A之后消除变为空串，此时错误的进入连消处理并试图取位置为-1处的元素将导致错误。

# 代码3

## 1. 错误类型

Time Limit Exceeded

## 2. 错误原因

对于插入位置之后长度为$n$的string对象，string.insert的复杂度为$O(n)$，因此进行$m$次插入的复杂度为$O(mn)$，而$m, n$最大值均为$500,000$，不符合题目要求的$1.5s$时限。

## 3. 测例

见文件03.in

## 4. 测例构造思路

将n和m取最大值，构造一个合法的测例即可。具体而言，初始序列为A-Z的循环，此后依次在序列首位插入A-Z即可。代码运行时间远超1.5s。

# 代码4

## 1. 错误类型

Wrong Answer

## 2. 错误原因

1. 第15行处应为size = right - left - 1，因为right-left会多算一个连续同色的位置。
2. 第17行应为a.erase(left+ 1, size); 因为left处为不连续同色的第一个位置，因此加1才是删除的起始位置

## 3. 测例

BAB
1
1 A

## 4. 测例构造思路

制造插入后连续2个的情况以触发第一个错误；制造删除时删除区段左侧有不同色珠子的情况以触发第二个错误。

插入A后，代码首先错误的将“AA”判定为可消除的而进行错误的消除操作；此后由于erase的错误，第一个B也被错误地消去。

# 代码5

## 1. 错误类型

Wrong Answer

## 2. 错误原因

27行处cin>>a;将导致无法读入空行，无法处理初始序列长度为0的情况。

## 3. 测例



1
0 A

## 4. 测例构造思路

使测例的初始序列长度为0即可。程序无法正常读入而出错。

# 代码6

## 1. 错误类型

Wrong Answer

## 2. 错误原因

70行-78行进行添加操作时，没有考虑到一直在同一个块里添加导致p数组越界访问的情况。

## 3. 测例

见文件06.in

## 4. 测例构造思路

使初始序列长度足以成为两个块，即长度为2049=2048+1，恰好分出两个块。

随后进行4096-2048+100次添加珠子的长度，全部在位置0处添加，且保证不会出现消除操作。此时由于内存越界访问，将会导致初始序列中在第2块的那唯一一个元素所在的地址被覆盖，导致答案错误。

# 代码7

## 1. 错误类型

Wrong Answer

## 2. 错误原因

第96行if应为while，否则无法处理由于消除操作导致的分块数组的某一块为空的情况（即如果当前分块数组有某一块为空，则左指针l的左移将会出错）。

## 3. 测例

见文件07.in

## 4. 测例构造思路

首先使初始序列长度足以构成多个块，且在插入一个字符后将会进行巨量的连消操作以至于大部分块都被置空。具体而言，初始序列为AABBCCDD...ZZ重复100次 + YXW...CBA + ZYWX...CBA重复98次 + ZYWX...DCB。

此后的操作为：

1. 在位置26000处插入Z。此操作将导致序列大量连消，得到的结果为AA。且AA位于分块数组的第一块，其后有大量空块。
2. 在位置2处插入A。此操作将导致插入的位置在最后一个块，但由于程序错误无法正确的消除，因为最后一个块和第一个块之间有很多空块。

# 代码8

## 1. 错误类型

Wrong Answer

## 2. 错误原因

完全没有考虑连消的情况，因此会出错。（具体而言，指92-113行）

## 3. 测例

AABBCCBA
1
4 C

## 4. 测例构造思路

只需要构造一个连消的情况即可。程序在消除CCC之后不会对A和B进行消除，因此出错。

# 代码9

## 1. 错误类型

Runtime Error

## 2. 错误原因

执行消除（131-142行）时，完全没有考虑l.first==r.first，即消除的部分位于同一个块内的情况，因此135行len将会取到负值，139行进行负值操作将一个负数赋给unsigned类型将会出现严重错误，plen[r.first]很有可能成为一个数值巨大的正数，进而导致一系列运行时错误，如p2a转换时出现非法地址访问。

## 3. 测例

BAAB
1
1 A

## 4. 测例构造思路

只需要构造一个执行同一个块内的消除的例子即可。插入A后，消除操作本应在第一个块内抹去“AAA”，但程序错误的先将plen[0]置为1，然后又错误的让len=-2，139行赋值操作出现无法控制的错误。

# 代码10

## 1. 错误类型

Wrong Answer

## 2. 错误原因

第147行，i应从l.first + 1开始循环。如果从l.first开始循环，则会导致l.first这一个块被置空，但alen却仍然正常，从而导致一系列答案错误。

## 3. 测例

见文件10.in

## 4. 测例构造思路

首先使初始序列长度足以构成多个块，且在插入一个字符后将会进行巨量的连消操作以至于大部分块应当被置空，但消除后第一个分块数组内部不是空串。具体而言，初始序列为ZY + AABBCCDD...ZZ重复100次 + YXW...CBA + ZYWX...CBA重复99次。

随后进行两个操作：

1. 在位置26002处插入Z，此操作将导致大量跨块连消。消除后本应得到ZY，但由于程序的错误，消除后的alen为2，但plen[0]却错误的被置为0。由于alen的正常，此时输出并不会有问题，因此进行第二个操作。
2. 在位置0处插入A，由于plen[0]在上一步操作中出现错误，此操作将错误的导致p[0][0]= ‘A’，并且会导致一些地址的访问错误，最终得到错误的答案。
