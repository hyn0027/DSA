# 1. 使用算法

总的来说，使用离散化处理涉及到的操作或查询位点以解决空间问题同时加速时间；使用线段树维护计数与查询操作。

具体而言，由于n的数据极大而m并不算大，因此1~n这些扑克牌中有相当一大部分的位置并不是查询或操作的关键位点（指左右位置）。考虑离散化，将非关键位点“缩点”，即连续的非关键点区间变成单个点，从而解决线段树的空间问题。

离散化”缩点“之后，需要处理的数据长度最多为4m，使用常规的线段树维护即可。使用一个flag（代码中名字为down）记录未向子节点更新的区间加，避免遍历子节点。当即将访问到某节点的子节点时，再向其子节点更新区间加。其余操作均是常规线段树的区间加和区间求和操作。

# 2. 问题处理

第一次做时，没有考虑周全而并未在离散化的数据之间加入“缩点”后的点，操作时直接将关键点之间的数据向右侧关键点合并，导致了查询和区间加出现严重问题。意识到之后改正，使用“缩点”方法解决。

# 3. 复杂度

## 3.1 时间复杂度

输入的时间时间复杂度为$O(m)$

离散化初始处理的时间复杂度为$O(mlogm)$

单次求离散化数据的时间复杂度为$O(logm)$

所有求离散化数据的总时间复杂度为$O(mlogm)$

建立线段树的时间复杂度为$O(logm)$

线段树单次区间操作的时间复杂度为$O(logm)$

线段树单次查询的时间复杂度为$O(logm)$

维护操作和查询的总时间复杂度为$O(mlogm)$

总时间复杂度为$O(mlogm)$

## 3.2 空间复杂度

输入数据存储的空间复杂度为$O(m)$

离散化的空间复杂度为$O(m)$

线段树的空间复杂度为$O(m)$

总空间复杂度为$O(m)$


# 4. 参考资料

无。
