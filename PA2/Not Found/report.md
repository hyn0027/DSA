# 1. 使用算法

由于串的长度不超过$2^{24}$，因此最终答案的长度必然不超过24，而对于某一个长度l，判断串中是否包含了这个长度的全部的串的种类这一过程是线性的（关于串的长度）。因此枚举长度进行判断是可行的，因为最坏情况也是只进行了$O(nlogn)$次运算，其中$n$为串的长度。

时间的问题已经解决，但本题空间仅有6mb，考虑到所需的空间只是用于标记0/1的flag，因此使用bitmap。

具体来说，使用bitmap存储串，同时使用bitmap标记某个子串的出现。比如在标记长度为$k$的子串$a_{0}a_{1}···a_{k - 1}$在输入的串中出现时，使用$A = a_0 \cdot 2^{k - 1} + a_1 \cdot 2^{k - 2} + ··· + a_{k - 1} \cdot 2^0$作为关键码，这样可以保证$0 \leq A \leq 2^k - 1$， 同时对于固定的$k$关键码互不相同。思路方面暴力枚举即可。

# 2. 问题处理

开始时由于使用了short作为循环变量而出错，改为int后解决问题。

# 3. 复杂度

## 3.1 时间复杂度

令$n$为输入串的长度

则输入的时间复杂度为$O(n)$

对于长度为$k$的子串，查找并标记的时间复杂度为$O(n)$

而$1 \leq k \leq \lfloor log_2n \rfloor + 1$

因此查找标记的总时间复杂度为$O(nlogn)$

最终的总时间复杂度为$O(nlogn)$

## 3.2 空间复杂度

所需的两个bitmap空间复杂度均为$O(n)$，总空间复杂度即位$O(n)$

> *针对这道题的额外说明：
>
> 两个bitmap存储的**数据**长度均为$maxn = 2 ^ {24}$，其占用的空间分别为$2 ^ {24}bit= 2MB$，总空间$4MB$，符合本题要求


# 4. 参考资料

教材中关于BitMap部分的介绍。

