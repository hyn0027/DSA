# 1. 使用算法

使用一颗Splay树，维护这个序列；特别地，为了支持翻转和哈希查询操作，支持查询某一位置的节点，为每个平衡树节点增加一个名为rev的lazy tag，用于翻转的记录；增加两个Hash结构体成员（如何使用会在后文提及）用于记录支持翻转的哈希值；增加一个sz表示子树的大小。

关于Hash，首先将字符串序列·转化为范围从0到25的整数序列；我们定义一个序列$a_{1}a{2}...a_{l - 1}a_l$的正向哈希值为$\begin{equation*}hash[0] =(\sum_{i=1}^la_i\cdot p^{l - i})\%hashmod\end{equation*}$，反向哈希值为$\begin{equation*}hash[1] =(\sum_{i=1}^la_i\cdot p^{i - 1})\%hashmod\end{equation*}$。在本题中取$p=998,244,353$，采用双哈希，取$hashmod[] = \{ 1e9 + 7, 1e9 + 9 \}$。对于一个值为$c$的节点$p$及其左右孩子$l,r$，假设左右孩子的大小为$sz_l, sz_r$，有$p.hash[0] = (l.hash[0] \cdot p^{sz_r + 1} + c\cdot p^{sz_r} + r.hash[0]) \% hashmod$，$p.hash[1] = (r.hash[1] \cdot p^{sz_l + 1} + c\cdot p^{sz_l} + l.hash[1]) \% hashmod$。

显然，如果翻转某个节点及其子树的节点，则交换正向与反向哈希值即可完成哈希的维护。

在平衡树的维护过程中，节点的插入、删除、zigzag、splay均为常规操作；在节点向上更新时，除了常规的更新sz，还需要使用上述公式更新hash值；在节点执行lazy tag标明的翻转时，还需要交换正反向哈希值；由于本题根据节点的位置定位节点，因此find的过程借助于左子树的大小逐步深入直至命中；在reverse操作中，特殊处理首尾位置，其余节点则将其左侧前驱splay至根，将其右侧后继splay至根的右孩子，则跟的右孩子的左孩子及其子树就是需要翻转的区间，直接修改rev即可；在询问操作中，使用与reverse相同的方法定位到子树，然后返回两个哈希值即可。

# 2. 问题处理

在写del时，忘记处理了边界情况下删除节点还有子树的情况导致错误，修改后正确。

此外在做完题后反思，本题如果能够在序列的最左侧和最右侧分别增加一个边界节点，则会大大减少需要边界特判的地方，可以有效简化代码实现。在提交的代码中没有使用这一方法，希望在以后的其他题目中使用。

# 3. 复杂度

## 3.1 时间复杂度

初始化$p$在模$hashmod$意义下的指数所需要的复杂度为$O(n + m)$

输入的总复杂度为$O(n + m)$

建树时单次插入操作的复杂度由于splay旋转至根的特性将不再仅仅是是均摊$O(logn)$，而是$O(1)$，因此建树的总复杂度为$O(n)$

对于$m$个操作，单次插入或删除或翻转或查询的均摊复杂度均为均摊$O(log(n + m))$，由平衡树的特性可以得出

综上所述，总时间复杂度为$O(n + mlog(n+ m))$

## 3.2 空间复杂度

预处理指数值的空间复杂度为$O(n + m)$

平衡树的空间复杂度为$O(n +m)$

除此之外不需要额外的非$O(1)$空间

因此总空间复杂度为$O(n +m)$


# 4. 参考资料

无
