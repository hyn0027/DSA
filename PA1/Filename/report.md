# 1. 使用算法

使用dp，令$dp(x, y)$表示第一个串的$[0, x]$转换为第二个串的$[0, y]$所需的转化次数

同时，保证$|x-y| \leq 2 \cdot  k_{max} = 2 \cdot 100 = 200$，因为如果不满足的话转化次数一定大于100大于k，必然不合法

通过一些下标的线性转换，保证dp(x, y)对应一个合法的地址，且数组的大小为$[n][2 \cdot k]$

具体而言，$dp(x, y) \Leftrightarrow f[x][y + 102 - x]$

对于dp本身：

转移方程为：

$\begin{equation}
dp(x,y)=\left\{
\begin{aligned}
dp(i - 1, j - 1) & , & A[i] = B[j], \\
min(dp(i - 1, j), dp(i, j - 1)) + 1 & , & A[i] \ne B[i]
\end{aligned}
\right.
\end{equation}$

初始化时只需要计算$dp(0, j), 0 \leq j \leq min(100, m - 1)$即可

# 2. 问题处理

在“使用算法”部分描述的问题处理方法之外，为减小空间复杂度，使用了short类型存储数据；为防止溢出，在存储的状态值大于200时直接将其置为101（在本题意义下所有大于k的值完全等价，均为-1，而k小于100）

# 3. 时空复杂度估算

## 3.1 时间复杂度

dp初始状态计算的时间复杂度为$O(1)$

dp时间复杂度为$O(nk)$

因此总时间复杂度为$O(nk)$.

## 3.2 空间复杂度

只有dp数组的空间复杂度不为$O(1)$，而f数组的空间复杂度为$O(nk)$

因此总空间复杂度为$O(nk)$.

# 4. 参考资料

无