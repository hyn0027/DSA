# 1. 使用算法

使用两个双向链表，分别正着、反着存字符序列。对于介于节点a和b之间的光标，且a是b的前驱，则将光标记录于a位置。

移动光标、插入、删除操作显然都能在常数时间内完成。对于翻转操作，则将两个相反的链表中对应区段取出，交换位置插回，在常数时间内实现翻转操作。对于输出操作，遍历即可。

# 2. 问题处理

最初写这道题时使用的是封装的Node指针存储每个节点，动态new和delete，但是出现MLE的情况。调试时，在每个Node的new时输出地址位置，由输出结果推测是由于内存的按位对齐特性导致理论空间至少翻倍，且排除了是内存泄漏导致错误的可能性。按位对齐导致大量占位空间无法被利用。因此选择直接开出数组并以下标记录前驱后继，而非动态new并记录指针，同时使用pragma命令使struct内部以1字节按位对齐，降低空间复杂度的常数。


# 3. 时空复杂度估算

## 3.1 时间复杂度

初始化的复杂度为$O(l)$，其中$l$为初始字符串长度。

由于所有操作除了输出全部都为$O(1)$，而题目保证输出文件大小存在一个最大值，因此可以忽略输出操作的时间复杂度，操作的时间复杂度为$O(N)$

总时间复杂度为$O(l + N)$， 其中$l$为初始字符串长度。

## 3.2 空间复杂度

为每一个可能出现的节点建立一个Node节点，以数组形式开出，其余所需的空间均为$O(1)$且不存在递归调用，故总空间复杂度为$O(l + N)$，其中$l$为初始字符串长度。


# 4. 参考资料

助教在网络学堂发布的习题课讲解视频。
