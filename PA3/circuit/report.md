# 1. 使用算法

使用Trie树存储串，为节省空间使用动态开点。为保证输出结果是最小的，从最后一个串向第一个串逐次添加。即计算开始前在Trie树里添加所有与n-1距离不超过k的位置的串，然后求解第n-1个串对应的答案。然后添加与n-2距离为k的串，求解第n-2个串对应的答案，以此类推。

使用时间戳规避了删除运算，即记录每个节点的时间戳为它及它的后代所存储的串中编号最小的是多少。在依据贪心策略在Trie里往下走的时候，如果一个节点的时间戳大于k所控制得范围那么必然不能进入这一支。时间戳在插入操作时维护，修改结尾处节点的时间戳，然后递归向上更新，每个节点的时间戳都是它两个人孩子的时间戳较小的那个。

查找的时候依据贪心，尽可能的向与被查找串相异的那一边走。最终走到的节点的时间戳就是答案。

特殊处理ans[0]=0的情况。这种情况只有一种可能，就是0~k+1这所有串完全一样。此时令ans[0]=1即可。

# 2. 问题处理

一开始没有注意到ans[0]=0的情形，导致错误，修改后正确。

# 3. 复杂度

## 3.1 时间复杂度

trie树的插入、查找、维护单次都是$O(l)$，$l$为串的长度，在本题中为64

共插入$n$次、查找$n$次，故时间复杂度为$O(nl)$

输入的时间复杂度为$O(n)$

故总时间复杂度为$O(nl)$，$l=64$

## 3.2 空间复杂度

空间上输入数据空间复杂度为$O(nl)$

所有串的所有位，每一位至多对应一个节点，故空间复杂度为$O(nl)$

总空间复杂度为$O(nl),\space l=64$

# 4. 参考资料

习题课材料

