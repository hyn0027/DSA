# 1. 使用算法

对于连通块的合并，使用路径优化的并查集算法维护。

根据题意，需要维护每个并查集（连通块）的第k大的点的值，支持合并与查询操作。为了支持堆的合并操作，我们只需要存每个并查集前k大的键值即可。考虑第k“大”并不好查询，不如维护一个大小严格小于等于k的小根堆，如果连通块大小D大于k，则查询第k“大”就等于查询小根堆中最小的键值；否则返回-1。合并时如果合并后的堆大小大于k则pop堆顶元素即可。由于每个元素至多pop一次，因此至多$n$次pop，时间上符合题目要求。更详细的分析见第三部分。

为了保证合并操作足够快，使用左式堆算法。

# 2. 问题处理

无

# 3. 复杂度

## 3.1 时间复杂度

易知初始化并查集和堆&前两行输入所需时间复杂度为$O(n)$

对于初始时的建边操作，视其等同为后续的加边操作处理。

对于单次加边操作，使用路径压缩的并查集单次查找的平均时间复杂度为$O(\alpha(sz))$，最坏时间复杂度为$O(log(sz))$，其中$sz$为并查集中元素有多少个。（此处并查集的分析参考了https://oi-wiki.org/ds/dsu-complexity/。）而堆的单次合并及单次pop的时间复杂度为$O(log(2 * k)) = O(logk)$。

对于单次查询操作，堆的时间复杂度为$O(1)$。

因此若总共有$a$次加边操作和$b$次查询操作，总时间复杂度为$O(a\cdot \alpha(n)) + O(alogk) + O(alogk) + O(b) = O(alogk + b)$。

从而本体的时间复杂度为$O(n) + O((q + m)logk) = O(n + (q + m)logk)$

## 3.2 空间复杂度

并查集所需空间为$O(n)$

左式堆所需空间为$O(n)$

堆合并递归空间$O(logk)$

并查集递归空间复杂度平均$O(\alpha(sz))$，最坏$O(log(sz))$

其余空间为$O(1)$

总空间复杂度 $O(n)$

# 4. 参考资料

讲义

并查集时间复杂度分析部分参考https://oi-wiki.org/ds/dsu-complexity/

