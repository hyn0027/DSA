# Lab3 Report

## 0.文件夹目录结构说明

avl.cpp为AVLTree的实现代码

splay.cpp为SplayTree的代码

data.cpp为数据生成器的代码

checker.cpp为批量测试代码

report.md（本文档）为实验报告

## 1. 数据结构的实现

### 1.1 AVL树

算法方面使用的是朴素的AVL树。

建立 ``struct Node``，使用 ``Node*``存储节点。结构体 ``Node``包含变量 ``int key, int h, Node*ch[2], Node* fa``，分别表示节点的键值，节点对应子树的高度，节点的左右孩子和节点的父亲。``Node``支持的方法有 ``Node* tallerch``，当保证输入节点有孩子的时候，它将返回它更高的那个孩子的指针。

建立 ``class AVLTree``，使用 ``AVLTree*``存储树。类 ``AVLTree``包含私有变量 ``Node* root, Node* hot``。类 ``AVLTree``支持的公有方法包括构造函数、``void insert(int key)``表示在树中插入键值为 ``key``的节点，``void remove(int key)``表示在树中删除键值为 ``key``的节点，``int search(int key)``表示在树中搜索键值不大于 ``key``的节点的键值并返回，同时若存在键值为 ``key``的节点则将 ``hot``设置为 ``key``前驱或后继的指针，若不存在则将 ``hot``设置为键值最靠近 ``key``的小于 ``key``和大于 ``key``的两个节点中是叶节点的那一个的指针。

在实现 ``AVLTree``的公有方法时，将一些操作拆分成以下私有方法：``void up(Node* p)``更新节点 ``p``的高度。``int BlanceFactor(Node* p)``和 ``bool Balanced(Node* p)``用于判定节点 ``p``是否平衡。``Node* succ(Node* p)``返回节点 ``p``的后继节点（输入保证有后继）。``void rotoveAt(Node* p)``和 ``void rotate(Node* p)``用于旋转失衡的节点的最高孙子 ``p``。 ``void removeAt(Node* p)``用于移除节点 ``p``。

利用以上私有方法，在 ``insert(key)``时若树空则新建根节点，否则在 ``search(key)``返回的 ``hot``处插入键值为 ``key``的儿子并判断更新根节点到插入节点路径的平衡。在 ``remove(key)``时移除 ``search(key)``返回的 ``hot``节点并判断更新根节点到删除节点路径的平衡。

### 1.2 Splay树

算法方面使用的是朴素的双旋Splay树。

建立 ``struct Node``，使用 ``Node*``存储节点。结构体 ``Node``包含变量 ``int key, Node* ch[2], Node* fa``，分别表示节点的键值，节点的左右孩子和节点的父亲。

建立 ``class Splay``，使用 ``Splay*``存储树。类 ``Splay``包含私有变量 ``Node* root, Node* hot``。类 ``Splay``支持的公有方法包括 ``void insert(int key)``，``void remove(int key)``。以上两个方法种的功能与 ``AVLTree``中的相同。此外构造函数会在树中插入一个极小点（键值为$-1$)和一个极大点（键值为$8500001$），用于防止操作节点的前驱或后继不存在。``int search(int key)``与 ``AVLTree``中的基本相同，除了会将 ``hot``设置成所找到的不大于 ``key``的节点位置并将其旋至根之外。

在实现 ``Splay``的公有方法时，将一些操作拆分成以下私有方法：``void rotate(Node* p)``在节点 ``p``的父亲处旋转。``void splay(Node* p, Node* goal)``将节点 ``p``旋转至 ``goal``的孩子的位置。

利用以上私有方法，在 ``insert(key)``时若树空则新建根节点，否则调用 ``search(key)``并在树根处插入键值为 ``key``的节点并重新连接。在 ``remove(key)``时调用 ``search(key)``，将根节点的后继旋至根节点右孩子处，删除根节点并重新连接。

## 2. 复杂度分析

### 2.1 AVL树

#### 2.1.1 空间复杂度

令程序执行过程中的最大树规模为$sz$，则显然空间复杂度为$O(sz)$。其他空间所需均为常数。

##### 2.1.2 时间复杂度

``insert,remove,search``的单次执行时间复杂度均为$O(h)$，而由于重平衡特性有$O(h) = O(logsz)$，因此令总操作数为$t$，则总时间复杂度为$O(tlogsz)$。

### 2.2 Splay树

#### 2.2.1 空间复杂度

令程序执行过程中的最大树规模为$sz$，则显然空间复杂度为$O(sz)$。其他空间所需均为常数。

#### 2.2.2 时间复杂度

``insert,remove,search``的单次执行的时间复杂度均为$O(h)$，而由于重平衡特性有均摊意义下的$O(h) = O(logsz)$，因此令总操作数为$t$，则总时间复杂度约为$O(tlogsz)$。

## 3. 数据生成器

### 3.1 目标

* 生成不同规模操作数的数据
* 按给定概率生成随机顺序数据
* 生成特殊顺序数据

### 3.2 实现

约定以下参数：

$maxT$：总操作数

$p_{insert}, p_{del}, p_{check}$：三个操作占总操作的大致比率

$insert_{up}$：值为真时插入数据递增，值为假使插入数据顺序随机

$del_{up}$：值为真时删除数据递增，值为假使插入删除顺序随机

$check_{up}$：值为真时查询数据递增，值为假使插入查询顺序随机

当$insert_{up},del_{up}, check_{up}$三者中至少一个为真时，生成的数据将按照4.性能测试一节中描述的特殊顺序排列。

在生成数据的过程中，使用了一颗splay树用于维护生成的数据，以保证数据合法，即不会插入键值相同的数，不会删除不存在的数等。

构造数据时，首先依据参数确定操作数并输出。然后依次根据概率随机或根据一定规则确定每一步的操作类型。确定操作类型后，若为插入操作，则随机一个键值，使用splay查询数据是否已经存在。如果存在则依次向后寻找直到第一个合法的数据。因为$8,500,000 > 2,000,000$，因此这种方法的期望复杂度并不高。考虑最坏情况，每个数据范围内的键值已被使用的概率约为$\frac{2,000,000}{8,500,000} = 0.23$，故最坏情况下每次查找的期望次数为$1/p \approx4.35$，是一个可接受范围的值。操作类型若为删除，则在数据范围内随机一个查找码，寻找树中不大于这个查找码的最大值，若不存在则将查找码乘二加一直至存在。操作类型若为查询，则随机一个数据范围内的值作为键值输出。当$insert_{up},del_{up}, check_{up}$三者中至少一个为真时，生成的数据将按照4.性能测试一节中描述的特殊顺序排列，基本生成方法不变，特殊的部分使用一些建议的累加操作处理。

## 4. 性能测试

性能测试结果如下表所示。每一横行成为一组。每组的数据由100次数据生成并调用代码测试取平均时间得到。其中时间$t_{AVL},t_{Splay}$以毫秒计。所有参数含义与前文保持一致。

|           | $maxT$ | $insert_{up}$ | $remove_{up}$ | $check_{up}$ | $p_{insert}$ | $p_{del}$ | $p_{check}$ | $t_{AVL}$ | $t_{Splay}$ | 备注                                                   |
| :-------: | :-------: | :-------------: | :-------------: | :------------: | :------------: | :---------: | :-----------: | :---------: | :-----------: | ------------------------------------------------------ |
| (default) |  100,000  |      false      |      false      |     false     |      0.5      |     0.2     |      0.3      |      -      |       -       |                                                        |
|     1     |           |                 |                 |               |               |             |               |   111.59   |    131.30    |                                                        |
|     2     |           |                 |                 |               |       1       |      0      |       0       |   137.64   |    164.72    |                                                        |
|     3     |           |      true      |                 |               |       1       |      0      |       0       |    93.30    |     59.07     |                                                        |
|     4     |  200,000  |                 |                 |               |      0.5      |      0      |      0.5      |   220.46   |    294.43    | 先进行100,000次insert操作，然后进行100,000次check操作  |
|     5     |  200,000  |      true      |                 |               |      0.5      |      0      |      0.5      |   172.83   |    182.67    | 同上                                                   |
|     6     |  200,000  |                 |                 |      true      |      0.5      |      0      |      0.5      |   204.48   |    232.35    | 同上                                                   |
|     7     |  200,000  |      true      |                 |      true      |      0.5      |      0      |      0.5      |   142.68   |    111.69    | 同上                                                   |
|     8     |  200,000  |                 |                 |               |      0.5      |     0.5     |       0       |   208.97   |    253.76    | 先进行100,000次insert操作，然后进行100,000次remove操作 |
|     9     |  200,000  |      true      |                 |               |      0.5      |     0.5     |       0       |   169.59   |    157.24    | 同上                                                   |
|    10    |  200,000  |                 |      true      |               |      0.5      |     0.5     |       0       |   182.06   |    177.83    | 同上                                                   |
|    11    |  200,000  |      true      |      true      |               |      0.5      |     0.5     |       0       |   154.51   |     94.84     | 同上                                                   |
|    12    |    100    |                 |                 |               |               |             |               |    36.56    |     33.89     |                                                        |
|    13    |   1,000   |                 |                 |               |               |             |               |    37.84    |     37.42     |                                                        |
|    14    |  10,000  |                 |                 |               |               |             |               |    45.16    |     43.73     |                                                        |
|    15    |  50,000  |                 |                 |               |               |             |               |    70.02    |     80.48     |                                                        |
|    16    |  500,000  |                 |                 |               |               |             |               |   512.91   |    681.78    |                                                        |
|    17    | 1,000,000 |                 |                 |               |               |             |               |   1101.72   |    1497.76    |                                                        |
|    18    | 2,000,000 |                 |                 |               |               |             |               |   2518.51   |    3329.95    |                                                        |
|    19    |           |                 |                 |               |      0.4      |     0.3     |               |   103.47   |    119.69    |                                                        |
|    20    |           |                 |                 |               |      0.6      |     0.1     |               |   128.87   |    160.63    |                                                        |
|    21    |           |                 |                 |               |      0.7      |      0      |               |   131.45   |    162.56    |                                                        |
|    22    |           |                 |                 |               |      0.3      |             |      0.5      |   103.00   |    121.08    |                                                        |
|    23    |           |                 |                 |               |      0.4      |             |      0.4      |   106.28   |    127.13    |                                                        |
|    24    |           |                 |                 |               |      0.6      |             |      0.2      |   132.49   |    160.50    |                                                        |
|    25    |           |                 |                 |               |      0.7      |             |      0.1      |   137.27   |    167.21    |                                                        |
|    26    |           |                 |                 |               |      0.8      |             |       0       |   144.89   |    173.01    |                                                        |
|    27    |           |                 |                 |               |               |     0.1     |      0.4      |   123.78   |    154.22    |                                                        |
|    28    |           |                 |                 |               |               |     0.3     |      0.2      |   107.19   |    125.52    |                                                        |

## 5. 性能分析

### 5.1 基础数据

为表中第1、2组数据，用于对照其余数据进行分析。

可知在随机数据下，AVL树的性能略好于Splay树。推测是由于AVL树保持严格平衡，而Splay树在完全随机的数据下有可能在有些时刻失衡，而数据没有相邻操作数据接近这一特性导致的。

### 5.2 插入操作分析

2、3组对照可知，当输入的顺序由随机变为升序后，两种平衡树的性能都将提升，这是由于AVL树在这一情况下将达到满二叉树的完美平衡，而Splay树由于其将操作节点旋转至根的特性，单词操作时间变为$O(1)$，从而大幅提升速度。也正是这个原因使得在升序插入数据时，Splay的表现大大优于AVL树。

### 5.3 查询操作分析

将2~7组做对比，可知$100,000$次查询操作所需的时间约为$81.18ms$（AVL）和$126.66ms$ (Splay)，做$100,000$次顺序查询所需的时间约为$66.11ms$ (AVL)和$55.13ms$ (Splay)。与插入操作类似，随机数据的查找速度AVL更快，而在顺序查询时二者速度均变快，Splay尤其变快。算法层面AVL的查询速度应当不变，因此考虑可能存在硬件层面连续访问导致AVL在顺序数据下查找速度变快。

### 5.4 删除操作分析

将2、3、8~11组做对比，可知可知$100,000$次删除操作所需的时间约为$73.81ms$（AVL）和$93.60ms$ (Splay)，做$100,000$次顺序删除所需的时间约为$52.82ms$ (AVL)和$24.44ms$ (Splay)。与插入、查询操作类似，随机数据的删除速度AVL更快，而在顺序删除时二者速度均变快，Splay尤其变快。类似的，推测AVL的删除速度变快是由于硬件方面地址的访问顺序导致。

### 5.5 数据规模

将1、12~18组数据做对比，并计算$\frac{time}{n\cdot log_2n}$如下表所示

|   |   $n$   | $t_{AVL}$ | $t_{Splay}$ | $n \cdot log_{10}n$ | $\frac{10000\cdot t_{AVL}}{n\cdot log_{10}n}$ | $\frac{10000\cdot t_{Splay}}{n\cdot log_{10}n}$ |
| :-: | :-------: | :---------: | :-----------: | :-------------------------------: | :---------------------------------: | :---------------------------------: |
| 12 |    100    |   36.56   | 33.89 | 200 | 1828.0 | 1694.5 |
| 13 |   1,000   | 37.84 | 37.42 | 3000 | 126.1 | 124.7 |
| 14 |  10,000  | 45.16 | 43.73 | 40000 | 11.29 | 10.9 |
| 15 |  50,000  | 70.02 | 80.48 | 284948 | 2.5 | 2.8 |
| 1 |  100,000  | 111.59 | 131.30 | 500000 | 2.2 | 2.6 |
| 16 |  500,000  | 512.91 | 681.78 | 2849485 | 1.8 | 2.4 |
| 17 | 1,000,000 | 1101.72 | 1497.76 | 6000000 | 1.8 | 2.5 |
| 18 | 2,000,000 | 2518.51 | 3329.95 | 12602060 | 2.0 | 2.6 |

由表中数据可知，数据极小时所耗时间与数据量不成规模，耗时极大，推测是由于一些初始化或IO操作耗时。当数据增大时，时间消耗趋于稳定，数据量与理论复杂度基本成线性关系。

### 5.6 操作类型占比

将1、19~28组数据做对比，可知减少插入增加删除可以减小运行时间，反之增多。减少插入增加查询可以减小运行时间，反之增多。减少删除增加查询可以增加运行时间，反之减小。以上结论应当与不同操作类型占比导致的树的规模不同相关。

